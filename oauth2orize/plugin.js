// Generated by CoffeeScript 1.7.1
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(['odo/express/app', 'odo/oauth2orize/db', 'odo/oauth2orize/server', 'oauth2orize', 'passport', 'passport-local', 'passport-http', 'passport-oauth2-client-password', 'passport-http-bearer', 'connect-ensure-login'], function(app, db, server, oauth2orize, passport, passportlocal, passportbasic, passportclientpassword, passportbearer, login) {
    var OAuth2;
    return OAuth2 = (function() {
      function OAuth2() {
        this.web = __bind(this.web, this);
        this.uid = __bind(this.uid, this);
        this.getRandomInt = __bind(this.getRandomInt, this);
      }

      OAuth2.prototype.getRandomInt = function(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      };

      OAuth2.prototype.uid = function(len) {
        var buf, charlen, chars, i;
        buf = [];
        chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        charlen = chars.length;
        i = 0;
        while (i < len) {
          buf.push(chars[this.getRandomInt(0, charlen - 1)]);
          i++;
        }
        return buf.join('');
      };

      OAuth2.prototype.web = function() {

        /*
        			BasicStrategy & ClientPasswordStrategy
        
        			These strategies are used to authenticate registered OAuth clients. They are
        			employed to protect the `token` endpoint, which consumers use to obtain
        			access tokens. The OAuth 2.0 specification suggests that clients use the
        			HTTP Basic scheme to authenticate. Use of the client password strategy
        			allows clients to send the same credentials in the request body (as opposed
        			to the `Authorization` header). While this approach is not recommended by
        			the specification, in practice it is quite common.
         */
        passport.use(new passportbasic.BasicStrategy(function(username, password, done) {
          return db.clients.findByClientId(username, function(err, client) {
            if (err) {
              return done(err);
            }
            if (!client) {
              return done(null, false);
            }
            if (client.clientSecret !== password) {
              return done(null, false);
            }
            return done(null, client);
          });
        }));
        passport.use(new passportclientpassword.Strategy(function(clientId, clientSecret, done) {
          return db.clients.findByClientId(clientId, function(err, client) {
            if (err) {
              return done(err);
            }
            if (!client) {
              return done(null, false);
            }
            if (client.clientSecret !== clientSecret) {
              return done(null, false);
            }
            return done(null, client);
          });
        }));

        /*
        			BearerStrategy
        
        			This strategy is used to authenticate users based on an access token (aka a
        			bearer token). The user must have previously authorized a client
        			application, which is issued an access token to make requests on behalf of
        			the authorizing user.
         */
        passport.use(new passportbearer.Strategy(function(accessToken, done) {
          return db.accessTokens.find(accessToken, function(err, token) {
            if (err) {
              return done(err);
            }
            if (!token) {
              return done(null, false);
            }
            return new UserProfile().get(token.userID, function(err, user) {
              var info;
              if (err) {
                return done(err);
              }
              if (!user) {
                return done(null, false);
              }
              info = {
                scope: '*'
              };
              return done(null, user, info);
            });
          });
        }));
        server.serializeClient(function(client, done) {
          return done(null, client.id);
        });
        server.deserializeClient(function(id, done) {
          return db.clients.find(id, function(err, client) {
            if (err) {
              return done(err);
            }
            return done(null, client);
          });
        });
        server.grant(oauth2orize.grant.code((function(_this) {
          return function(client, redirectURI, user, ares, done) {
            var code;
            code = _this.uid(16);
            return db.authorizationCodes.save(code, client.id, redirectURI, user.id, function(err) {
              if (err) {
                return done(err);
              }
              return done(null, code);
            });
          };
        })(this)));
        server.exchange(oauth2orize.exchange.code((function(_this) {
          return function(client, code, redirectURI, done) {
            return db.authorizationCodes.find(code, function(err, authCode) {
              if (err) {
                return done(err);
              }
              if (authCode == null) {
                return done(null, false);
              }
              if (client.id !== authCode.clientID) {
                return done(null, false);
              }
              if (redirectURI !== authCode.redirectURI) {
                return done(null, false);
              }
              return db.authorizationCodes["delete"](code, function(err) {
                var token;
                if (err) {
                  return done(err);
                }
                token = _this.uid(256);
                return db.accessTokens.save(token, authCode.userID, authCode.clientID, function(err) {
                  if (err) {
                    return done(err);
                  }
                  return done(null, token);
                });
              });
            });
          };
        })(this)));
        return app.post('/odo/auth/oauth2/token', [
          passport.authenticate(['basic', 'oauth2-client-password'], {
            session: false
          }), server.token(), server.errorHandler()
        ]);
      };

      return OAuth2;

    })();
  });

}).call(this);
